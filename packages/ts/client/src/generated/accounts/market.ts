/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';

export const MARKET_DISCRIMINATOR = new Uint8Array([
  219, 190, 213, 55, 0, 227, 198, 154,
]);

export function getMarketDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MARKET_DISCRIMINATOR);
}

export type Market = {
  discriminator: ReadonlyUint8Array;
  /** Struct version */
  version: number;
  /** Bump seed for the market account */
  bump: ReadonlyUint8Array;
  /** Liquidity provider: Orca, Raydium, etc... */
  liquidityProvider: number;
  /** Liquidity pool address */
  pool: Address;
  /** Address Lookup Table address for this market */
  addressLookupTable: Address;
  /** Maximum allowed leverage for this market */
  maxLeverage: number;
  /** Protocol fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  protocolFee: number;
  /** Protocol fee on collateral (funds provided by a user) denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  protocolFeeOnCollateral: number;
  /** Liquidation fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  liquidationFee: number;
  /** Liquidation threshold. The position is treated as unhealthy if debt > balance * (liquidation_threshold / HUNDRED_PERCENT). */
  liquidationThreshold: number;
  /** Limit order execution fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  limitOrderExecutionFee: number;
  /** Oracle price deviation threshold in percent. */
  oraclePriceDeviationThreshold: number;
  /** True if the market is disabled (no more position can be opened). */
  disabled: boolean;
  /** Total borrowed shares of token A. */
  borrowedSharesA: bigint;
  /** Total borrowed shares of token B. */
  borrowedSharesB: bigint;
  /** Total borrow limit for this market in token A. */
  borrowLimitA: bigint;
  /** Total borrow limit for this market in token B. */
  borrowLimitB: bigint;
  /** Maximum allowed swap slippage percentage. If it's set to zero, the DEFAULT_MAX_SWAP_SLIPPAGE is used. */
  maxSwapSlippage: number;
  /** Reserved */
  reserved: ReadonlyUint8Array;
};

export type MarketArgs = {
  /** Struct version */
  version: number;
  /** Bump seed for the market account */
  bump: ReadonlyUint8Array;
  /** Liquidity provider: Orca, Raydium, etc... */
  liquidityProvider: number;
  /** Liquidity pool address */
  pool: Address;
  /** Address Lookup Table address for this market */
  addressLookupTable: Address;
  /** Maximum allowed leverage for this market */
  maxLeverage: number;
  /** Protocol fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  protocolFee: number;
  /** Protocol fee on collateral (funds provided by a user) denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  protocolFeeOnCollateral: number;
  /** Liquidation fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  liquidationFee: number;
  /** Liquidation threshold. The position is treated as unhealthy if debt > balance * (liquidation_threshold / HUNDRED_PERCENT). */
  liquidationThreshold: number;
  /** Limit order execution fee denominated in hundredths of a bip. (Value of 100 is equal to 0.01%) */
  limitOrderExecutionFee: number;
  /** Oracle price deviation threshold in percent. */
  oraclePriceDeviationThreshold: number;
  /** True if the market is disabled (no more position can be opened). */
  disabled: boolean;
  /** Total borrowed shares of token A. */
  borrowedSharesA: number | bigint;
  /** Total borrowed shares of token B. */
  borrowedSharesB: number | bigint;
  /** Total borrow limit for this market in token A. */
  borrowLimitA: number | bigint;
  /** Total borrow limit for this market in token B. */
  borrowLimitB: number | bigint;
  /** Maximum allowed swap slippage percentage. If it's set to zero, the DEFAULT_MAX_SWAP_SLIPPAGE is used. */
  maxSwapSlippage: number;
  /** Reserved */
  reserved: ReadonlyUint8Array;
};

export function getMarketEncoder(): Encoder<MarketArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['version', getU16Encoder()],
      ['bump', fixEncoderSize(getBytesEncoder(), 1)],
      ['liquidityProvider', getU8Encoder()],
      ['pool', getAddressEncoder()],
      ['addressLookupTable', getAddressEncoder()],
      ['maxLeverage', getU32Encoder()],
      ['protocolFee', getU16Encoder()],
      ['protocolFeeOnCollateral', getU16Encoder()],
      ['liquidationFee', getU32Encoder()],
      ['liquidationThreshold', getU32Encoder()],
      ['limitOrderExecutionFee', getU32Encoder()],
      ['oraclePriceDeviationThreshold', getU32Encoder()],
      ['disabled', getBooleanEncoder()],
      ['borrowedSharesA', getU64Encoder()],
      ['borrowedSharesB', getU64Encoder()],
      ['borrowLimitA', getU64Encoder()],
      ['borrowLimitB', getU64Encoder()],
      ['maxSwapSlippage', getU32Encoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 211)],
    ]),
    (value) => ({ ...value, discriminator: MARKET_DISCRIMINATOR })
  );
}

export function getMarketDecoder(): Decoder<Market> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['version', getU16Decoder()],
    ['bump', fixDecoderSize(getBytesDecoder(), 1)],
    ['liquidityProvider', getU8Decoder()],
    ['pool', getAddressDecoder()],
    ['addressLookupTable', getAddressDecoder()],
    ['maxLeverage', getU32Decoder()],
    ['protocolFee', getU16Decoder()],
    ['protocolFeeOnCollateral', getU16Decoder()],
    ['liquidationFee', getU32Decoder()],
    ['liquidationThreshold', getU32Decoder()],
    ['limitOrderExecutionFee', getU32Decoder()],
    ['oraclePriceDeviationThreshold', getU32Decoder()],
    ['disabled', getBooleanDecoder()],
    ['borrowedSharesA', getU64Decoder()],
    ['borrowedSharesB', getU64Decoder()],
    ['borrowLimitA', getU64Decoder()],
    ['borrowLimitB', getU64Decoder()],
    ['maxSwapSlippage', getU32Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 211)],
  ]);
}

export function getMarketCodec(): Codec<MarketArgs, Market> {
  return combineCodec(getMarketEncoder(), getMarketDecoder());
}

export function decodeMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Market, TAddress>;
export function decodeMarket<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Market, TAddress>;
export function decodeMarket<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Market, TAddress> | MaybeAccount<Market, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getMarketDecoder()
  );
}

export async function fetchMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Market, TAddress>> {
  const maybeAccount = await fetchMaybeMarket(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeMarket<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Market, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeMarket(maybeAccount);
}

export async function fetchAllMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Market>[]> {
  const maybeAccounts = await fetchAllMaybeMarket(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeMarket(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Market>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeMarket(maybeAccount));
}

export function getMarketSize(): number {
  return 348;
}
