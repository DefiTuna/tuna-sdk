/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI32Decoder,
  getI32Encoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getTunaPositionStateDecoder,
  getTunaPositionStateEncoder,
  type TunaPositionState,
  type TunaPositionStateArgs,
} from '../types';

export const TUNA_POSITION_DISCRIMINATOR = new Uint8Array([
  76, 197, 161, 51, 232, 15, 137, 220,
]);

export function getTunaPositionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    TUNA_POSITION_DISCRIMINATOR
  );
}

export type TunaPosition = {
  discriminator: ReadonlyUint8Array;
  /** Struct version */
  version: number;
  /** Bump seed for the tuna position account */
  bump: ReadonlyUint8Array;
  /** The authority address used for managing the position */
  authority: Address;
  /** Liquidity pool address this position belongs to */
  pool: Address;
  /** The mint address for token A */
  mintA: Address;
  /** The mint address for token B */
  mintB: Address;
  /** The mint address for the position token (minted and used in Orca/Raydium) */
  positionMint: Address;
  /** Total minted liquidity */
  liquidity: bigint;
  /** Position lower tick */
  tickLowerIndex: number;
  /** Position upper tick */
  tickUpperIndex: number;
  /** The amount of shares borrowed by user from vault A. */
  loanSharesA: bigint;
  /** The amount of shares borrowed by user from vault B. */
  loanSharesB: bigint;
  /** The amount of funds borrowed by user from vault A. Doesn't include accrued interest. */
  loanFundsA: bigint;
  /** The amount of funds borrowed by user from vault B. Doesn't include accrued interest. */
  loanFundsB: bigint;
  /** The leftovers are funds that couldn't be added to a pool as liquidity. They remain in the position token account. */
  leftoversA: bigint;
  /** The leftovers are funds that couldn't be added to a pool as liquidity. They remain in the position token account. */
  leftoversB: bigint;
  /** Position entry tick index. */
  tickEntryIndex: number;
  /** Position stop loss tick index. */
  tickStopLossIndex: number;
  /** Position stop loss tick index. */
  tickTakeProfitIndex: number;
  /** Position state: normal, liquidated, closed by limit order */
  state: TunaPositionState;
  /**
   * OBSOLETE: Which token to swap collateral to when a limit order is executed. Used for position ver 4 or older.
   * bits 0..1: Stop loss swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * bits 2..3: Take profit swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   */
  swapToTokenOnLimitOrder: number;
  /** Yield amount in token A that has already been collected and compounded into the position. */
  compoundedYieldA: bigint;
  /** Yield amount in token B that has already been collected and compounded into the position. */
  compoundedYieldB: bigint;
  /**
   * Position options.
   * Bits 0..1: Stop loss swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * Bits 2..3: Take profit swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * Bits 4..5: Yield auto compounding. 0 - don't compound, 1 - compound yield, 2 - compound yield with leverage
   */
  flags: number;
  /** Reserved */
  reserved: ReadonlyUint8Array;
};

export type TunaPositionArgs = {
  /** Struct version */
  version: number;
  /** Bump seed for the tuna position account */
  bump: ReadonlyUint8Array;
  /** The authority address used for managing the position */
  authority: Address;
  /** Liquidity pool address this position belongs to */
  pool: Address;
  /** The mint address for token A */
  mintA: Address;
  /** The mint address for token B */
  mintB: Address;
  /** The mint address for the position token (minted and used in Orca/Raydium) */
  positionMint: Address;
  /** Total minted liquidity */
  liquidity: number | bigint;
  /** Position lower tick */
  tickLowerIndex: number;
  /** Position upper tick */
  tickUpperIndex: number;
  /** The amount of shares borrowed by user from vault A. */
  loanSharesA: number | bigint;
  /** The amount of shares borrowed by user from vault B. */
  loanSharesB: number | bigint;
  /** The amount of funds borrowed by user from vault A. Doesn't include accrued interest. */
  loanFundsA: number | bigint;
  /** The amount of funds borrowed by user from vault B. Doesn't include accrued interest. */
  loanFundsB: number | bigint;
  /** The leftovers are funds that couldn't be added to a pool as liquidity. They remain in the position token account. */
  leftoversA: number | bigint;
  /** The leftovers are funds that couldn't be added to a pool as liquidity. They remain in the position token account. */
  leftoversB: number | bigint;
  /** Position entry tick index. */
  tickEntryIndex: number;
  /** Position stop loss tick index. */
  tickStopLossIndex: number;
  /** Position stop loss tick index. */
  tickTakeProfitIndex: number;
  /** Position state: normal, liquidated, closed by limit order */
  state: TunaPositionStateArgs;
  /**
   * OBSOLETE: Which token to swap collateral to when a limit order is executed. Used for position ver 4 or older.
   * bits 0..1: Stop loss swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * bits 2..3: Take profit swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   */
  swapToTokenOnLimitOrder: number;
  /** Yield amount in token A that has already been collected and compounded into the position. */
  compoundedYieldA: number | bigint;
  /** Yield amount in token B that has already been collected and compounded into the position. */
  compoundedYieldB: number | bigint;
  /**
   * Position options.
   * Bits 0..1: Stop loss swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * Bits 2..3: Take profit swap. 0 - no swap, 1 - swap to token A, 2 - swap to token B
   * Bits 4..5: Yield auto compounding. 0 - don't compound, 1 - compound yield, 2 - compound yield with leverage
   */
  flags: number;
  /** Reserved */
  reserved: ReadonlyUint8Array;
};

export function getTunaPositionEncoder(): Encoder<TunaPositionArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['version', getU16Encoder()],
      ['bump', fixEncoderSize(getBytesEncoder(), 1)],
      ['authority', getAddressEncoder()],
      ['pool', getAddressEncoder()],
      ['mintA', getAddressEncoder()],
      ['mintB', getAddressEncoder()],
      ['positionMint', getAddressEncoder()],
      ['liquidity', getU128Encoder()],
      ['tickLowerIndex', getI32Encoder()],
      ['tickUpperIndex', getI32Encoder()],
      ['loanSharesA', getU64Encoder()],
      ['loanSharesB', getU64Encoder()],
      ['loanFundsA', getU64Encoder()],
      ['loanFundsB', getU64Encoder()],
      ['leftoversA', getU64Encoder()],
      ['leftoversB', getU64Encoder()],
      ['tickEntryIndex', getI32Encoder()],
      ['tickStopLossIndex', getI32Encoder()],
      ['tickTakeProfitIndex', getI32Encoder()],
      ['state', getTunaPositionStateEncoder()],
      ['swapToTokenOnLimitOrder', getU8Encoder()],
      ['compoundedYieldA', getU64Encoder()],
      ['compoundedYieldB', getU64Encoder()],
      ['flags', getU32Encoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 62)],
    ]),
    (value) => ({ ...value, discriminator: TUNA_POSITION_DISCRIMINATOR })
  );
}

export function getTunaPositionDecoder(): Decoder<TunaPosition> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['version', getU16Decoder()],
    ['bump', fixDecoderSize(getBytesDecoder(), 1)],
    ['authority', getAddressDecoder()],
    ['pool', getAddressDecoder()],
    ['mintA', getAddressDecoder()],
    ['mintB', getAddressDecoder()],
    ['positionMint', getAddressDecoder()],
    ['liquidity', getU128Decoder()],
    ['tickLowerIndex', getI32Decoder()],
    ['tickUpperIndex', getI32Decoder()],
    ['loanSharesA', getU64Decoder()],
    ['loanSharesB', getU64Decoder()],
    ['loanFundsA', getU64Decoder()],
    ['loanFundsB', getU64Decoder()],
    ['leftoversA', getU64Decoder()],
    ['leftoversB', getU64Decoder()],
    ['tickEntryIndex', getI32Decoder()],
    ['tickStopLossIndex', getI32Decoder()],
    ['tickTakeProfitIndex', getI32Decoder()],
    ['state', getTunaPositionStateDecoder()],
    ['swapToTokenOnLimitOrder', getU8Decoder()],
    ['compoundedYieldA', getU64Decoder()],
    ['compoundedYieldB', getU64Decoder()],
    ['flags', getU32Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 62)],
  ]);
}

export function getTunaPositionCodec(): Codec<TunaPositionArgs, TunaPosition> {
  return combineCodec(getTunaPositionEncoder(), getTunaPositionDecoder());
}

export function decodeTunaPosition<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<TunaPosition, TAddress>;
export function decodeTunaPosition<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<TunaPosition, TAddress>;
export function decodeTunaPosition<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<TunaPosition, TAddress> | MaybeAccount<TunaPosition, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getTunaPositionDecoder()
  );
}

export async function fetchTunaPosition<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<TunaPosition, TAddress>> {
  const maybeAccount = await fetchMaybeTunaPosition(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeTunaPosition<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<TunaPosition, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeTunaPosition(maybeAccount);
}

export async function fetchAllTunaPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<TunaPosition>[]> {
  const maybeAccounts = await fetchAllMaybeTunaPosition(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeTunaPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<TunaPosition>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTunaPosition(maybeAccount));
}

export function getTunaPositionSize(): number {
  return 339;
}
